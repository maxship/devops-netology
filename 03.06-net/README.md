
# Домашнее задание к занятию "3.6. Компьютерные сети, лекция 1"

1. Необязательное задание:
можно посмотреть целый фильм в консоли `telnet towel.blinkenlights.nl` :)

2. Узнайте о том, сколько действительно независимых (не пересекающихся) каналов есть в разделяемой среде WiFi при работе на 2.4 ГГц. Стандарты с полосой 5 ГГц более актуальны, но регламенты на 5 ГГц существенно различаются в разных странах, а так же не раз обновлялись. В качестве дополнительного вопроса вне зачета, попробуйте найти актуальный ответ и на этот вопрос.

Шаг каналов частот в диапазоне 2.4 ГГц, на которых может работать оборудование, составляет 5 МГц в интервале с 2.412 Ггц до 2.484 Ггц (всего 14  каналов), а ширина канала для стандарта 802.11 b/g/n составляет 20 Мгц. 

Это означает, что рабочие частоты оборудования перекрываются, и независимых друг от друга каналов всего 3. Например 1 (2,412 ГГц), 6 (2,437 ГГц) и 11 (2,462 ГГц), частоты которых отличаются более чем на 20 МГц. Так же можно использовать каналы 2, 7, 12 или 3, 8, 13.

![Screenshot_13](https://user-images.githubusercontent.com/72273610/122647572-8ee1a300-d146-11eb-9378-f274a277f357.png)

3. Адрес канального уровня – MAC адрес – это 6 байт, первые 3 из которых называются OUI – Organizationally Unique Identifier или уникальный идентификатор организации. Какому производителю принадлежит MAC `38:f9:d3:55:55:79`?

Соответствие MAC адресов производителям мжно посмотеть, например, здесь: https://uic.io/en/mac/. 

![Screenshot_14](https://user-images.githubusercontent.com/72273610/122884976-7947c580-d360-11eb-8682-653c2dba74f0.png)


4. Каким будет payload TCP сегмента, если Ethernet MTU задан в 9001 байт, размер заголовков IPv4 – 20 байт, а TCP – 32 байта?

```
payload (MSS) = 9001(MTU) - 20(IP) - 32(TCP) = 8949
```

![Screenshot_15](https://user-images.githubusercontent.com/72273610/122891551-6c2dd500-d366-11eb-95a4-88f9cddd05d6.png)


5. Может ли во флагах TCP одновременно быть установлены флаги SYN и FIN при штатном режиме работы сети? Почему да или нет?

Механизм передачи TCP пакетов делится на 3 стадии: последовательно осуществляется инициализация соединения, передача данных и завершение соединения. Установление соединения, в свою очередь, требует выполнения "трестороннего рукопожатия" с использования флагов SYN и ACK. Флаг FIN, соответственно, используется в стадии завершения соединения после выполнения первых двух этапов. Поэтому при штатной работе сети флаги SYN и FIN не могут находиться в одном пакете.

6. `ss -ula sport = :53` на хосте имеет следующий вывод:

```bash
State           Recv-Q          Send-Q                   Local Address:Port                     Peer Address:Port          Process
UNCONN          0               0                        127.0.0.53%lo:domain                        0.0.0.0:*
```
Почему в `State` присутствует только `UNCONN`, и может ли там присутствовать, например, `TIME-WAIT`?


Ключ ```-u``` показывает в выводе команды только сокеты UDP. А поскольку UDP - это протокол без установления соединений, то в параметре ``state`` всегда будет значение ```UNCONN``` или пустое значение, если использовать вместо ``ss`` ``netstat``.

7. Обладая знаниями о том, как штатным образом завершается соединение (FIN от инициатора, FIN-ACK от ответчика, ACK от инициатора), опишите в каких состояниях будет находиться TCP соединение в каждый момент времени на клиенте и на сервере при завершении. Схема переходов состояния соединения вам в этом поможет.

8. TCP порт – 16 битное число. Предположим, 2 находящихся в одной сети хоста устанавливают между собой соединения. Каким будет теоретическое максимальное число соединений, ограниченное только лишь параметрами L4, которое параллельно может установить клиент с одного IP адреса к серверу с одним IP адресом? Сколько соединений сможет обслужить сервер от одного клиента? А если клиентов больше одного?

9. Может ли сложиться ситуация, при которой большое число соединений TCP на хосте находятся в состоянии  `TIME-WAIT`? Если да, то является ли она хорошей или плохой? Подкрепите свой ответ пояснением той или иной оценки.

10. Чем особенно плоха фрагментация UDP относительно фрагментации TCP?

TCP разбивает данные на сегменты, размер которых не превышает размера MTU, то есть фрагментация осуществляется на транспортном уровне. При потере сегмента он переотправляется.

Протокол UDP использует фрагментацию на сетевом уровне. Уровень IP не имеет механизмов типа таймаута и повторной передачи, аналогичных транспортному уровню (TCP). Поэтому, если один из фрагментов датаграммы потерян, переотправить только потерянный фрагмент невозможно - требуется повторноя отправка всей датаграммы. Это ведет к проблемам с производительностью, поэтому IP фрагментацию желательно избегать на уровне приложения.


11. Если бы вы строили систему удаленного сбора логов, то есть систему, в которой несколько хостов отправяют на центральный узел генерируемые приложениями логи (предположим, что логи – текстовая информация), какой протокол транспортного уровня вы выбрали бы и почему? Проверьте ваше предположение самостоятельно, узнав о стандартном протоколе syslog.

Для удаленного сбора логов я бы использовал TCP, поскольку он обеспечивает гарантированную доставку сообщений (для логов это может быть важно).

По факту используется как UDP, так и TCP.

12. Сколько портов TCP находится в состоянии прослушивания на вашей виртуальной машине с Ubuntu, и каким процессам они принадлежат?

```
vagrant@vagrant:~$ ss -t -4 state listening -n | column -t
Recv-Q  Send-Q  Local             Address:Port  Peer  Address:Port  Process
0       4096    127.0.0.53%lo:53  0.0.0.0:*
0       128     0.0.0.0:22        0.0.0.0:*
0       4096    127.0.0.1:8125    0.0.0.0:*
0       4096    0.0.0.0:19999     0.0.0.0:*
0       4096    0.0.0.0:111       0.0.0.0:*

vagrant@vagrant:~$ ss -t -4 state listening | column -t
Recv-Q  Send-Q  Local                 Address:Port  Peer  Address:Port  Process
0       4096    127.0.0.53%lo:domain  0.0.0.0:*
0       128     0.0.0.0:ssh           0.0.0.0:*
0       4096    127.0.0.1:8125        0.0.0.0:*
0       4096    0.0.0.0:19999         0.0.0.0:*
0       4096    0.0.0.0:sunrpc        0.0.0.0:*

vagrant@vagrant:~$ sudo lsof -ni :53,22,8125,19999,111 | grep TCP | grep IPv4
systemd      1            root   35u  IPv4   1798      0t0  TCP *:sunrpc (LISTEN)
rpcbind    544            _rpc    4u  IPv4   1798      0t0  TCP *:sunrpc (LISTEN)
systemd-r  545 systemd-resolve   13u  IPv4  20386      0t0  TCP 127.0.0.53:domain (LISTEN)
netdata    613         netdata    4u  IPv4  22850      0t0  TCP *:19999 (LISTEN)
netdata    613         netdata   21u  IPv4  33706      0t0  TCP 10.0.2.15:19999->10.0.2.2:60600 (ESTABLISHED)
netdata    613         netdata   33u  IPv4  23526      0t0  TCP 127.0.0.1:8125 (LISTEN)
sshd       697            root    3u  IPv4  22889      0t0  TCP *:ssh (LISTEN)
sshd      1391            root    4u  IPv4  30449      0t0  TCP 10.0.2.15:ssh->10.0.2.2:50988 (ESTABLISHED)
sshd      1442         vagrant    4u  IPv4  30449      0t0  TCP 10.0.2.15:ssh->10.0.2.2:50988 (ESTABLISHED)
```

13. Какой ключ нужно добавить в `tcpdump`, чтобы он начал выводить не только заголовки, но и содержимое фреймов в текстовом виде? А в текстовом и шестнадцатиричном?

14. Попробуйте собрать дамп трафика с помощью `tcpdump` на основном интерфейсе вашей виртуальной машины и посмотреть его через tshark или Wireshark (можно ограничить число пакетов `-c 100`). Встретились ли вам какие-то установленные флаги Internet Protocol (не флаги TCP, а флаги IP)? Узнайте, какие флаги бывают. Как на самом деле называется стандарт Ethernet, фреймы которого попали в ваш дамп? Можно ли где-то в дампе увидеть OUI?


В выводе ```tcpdump``` эти флаги есть:
```
13:28:41.200808 IP (tos 0x10, ttl 64, id 3107, offset 0, flags [DF], proto TCP (6), length 92)
    vagrant.ssh > _gateway.50988: tcp 52
13:28:41.201060 IP (tos 0x10, ttl 64, id 3108, offset 0, flags [DF], proto TCP (6), length 84)
    vagrant.ssh > _gateway.50988: tcp 44
13:28:41.201309 IP (tos 0x10, ttl 64, id 3109, offset 0, flags [DF], proto TCP (6), length 84)
    vagrant.ssh > _gateway.50988: tcp 44
13:28:41.201557 IP (tos 0x10, ttl 64, id 3110, offset 0, flags [DF], proto TCP (6), length 84)
    vagrant.ssh > _gateway.50988: tcp 44
13:28:41.201805 IP (tos 0x10, ttl 64, id 3111, offset 0, flags [DF], proto TCP (6), length 84)
    vagrant.ssh > _gateway.50988: tcp 44
13:28:41.202061 IP (tos 0x0, ttl 64, id 11507, offset 0, flags [none], proto TCP (6), length 40)
    _gateway.50988 > vagrant.ssh: tcp 0
13:28:41.202061 IP (tos 0x0, ttl 64, id 11508, offset 0, flags [none], proto TCP (6), length 40)
    _gateway.50988 > vagrant.ssh: tcp 0
13:28:41.202061 IP (tos 0x0, ttl 64, id 11509, offset 0, flags [none], proto TCP (6), length 40)
    _gateway.50988 > vagrant.ssh: tcp 0
13:28:41.202061 IP (tos 0x0, ttl 64, id 11510, offset 0, flags [none], proto TCP (6), length 40)
    _gateway.50988 > vagrant.ssh: tcp 0
13:28:41.202061 IP (tos 0x0, ttl 64, id 11511, offset 0, flags [none], proto TCP (6), length 40)
    _gateway.50988 > vagrant.ssh: tcp 0
```

Флаги протокола IP, указывающие на фрагментацию:

R - задается равным 0.  

DF - не фрагметнировано.  

MF -еще фрагменты (означает, что в за текущим фрагментом датаграммы следует еще фрагмент).


Вывести их в tshark у меня не получилось, пока не разобрался в чем дело. Присутствуют только флаги TCP:
```
vagrant@vagrant:~$ sudo tcpdump -c 100 -w ~/tcpdump.pcap
tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
100 packets captured
151 packets received by filter
0 packets dropped by kernel

vagrant@vagrant:~$ tshark -r ~/tcpdump.pcap
    ........
   68  12.607527    10.0.2.15 → 10.0.2.2     HTTP 1251 HTTP/1.1 200 OK  (application/json)
   69  12.607760     10.0.2.2 → 10.0.2.15    TCP 60 50813 → 19999 [ACK] Seq=15463 Ack=24860 Win=65535 Len=0
   70  12.613499     10.0.2.2 → 10.0.2.15    HTTP 802 GET /api/v1/data?chart=system.cpu&format=json&points=123&group=average&gtime=0&options=ms%7Cflip%7Cjsonwrap%7Cnonzero&after=-120&dimensions=iowait&_=1624363683114 HTTP/1.1
   71  12.613830    10.0.2.15 → 10.0.2.2     HTTP 1098 HTTP/1.1 200 OK  (application/json)
   72  12.614169     10.0.2.2 → 10.0.2.15    TCP 60 50813 → 19999 [ACK] Seq=16211 Ack=25904 Win=65535 Len=0
   73  12.620026     10.0.2.2 → 10.0.2.15    HTTP 803 GET /api/v1/data?chart=system.cpu&format=json&points=123&group=average&gtime=0&options=ms%7Cflip%7Cjsonwrap%7Cnonzero&after=-120&dimensions=softirq&_=1624363683115 HTTP/1.1
   74  12.620360    10.0.2.15 → 10.0.2.2     HTTP 1099 HTTP/1.1 200 OK  (application/json)
   75  12.620576     10.0.2.2 → 10.0.2.15    TCP 60 50813 → 19999 [ACK] Seq=16960 Ack=26949 Win=65535 Len=0
   76  12.722889     10.0.2.2 → 10.0.2.15    TCP 60 52394 → 19999 [SYN] Seq=0 Win=65535 Len=0 MSS=1460
   77  12.722889     10.0.2.2 → 10.0.2.15    TCP 60 60566 → 19999 [SYN] Seq=0 Win=65535 Len=0 MSS=1460
   78  12.722889     10.0.2.2 → 10.0.2.15    TCP 60 59269 → 19999 [SYN] Seq=0 Win=65535 Len=0 MSS=1460
   79  12.722930    10.0.2.15 → 10.0.2.2     TCP 58 19999 → 52394 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=1460
   80  12.722983    10.0.2.15 → 10.0.2.2     TCP 58 19999 → 60566 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=1460
   81  12.723028    10.0.2.15 → 10.0.2.2     TCP 58 19999 → 59269 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=1460
   82  12.723299     10.0.2.2 → 10.0.2.15    TCP 60 57982 → 19999 [SYN] Seq=0 Win=65535 Len=0 MSS=1460
   83  12.723299     10.0.2.2 → 10.0.2.15    TCP 60 52394 → 19999 [ACK] Seq=1 Ack=1 Win=65535 Len=0
   84  12.723299     10.0.2.2 → 10.0.2.15    TCP 60 63482 → 19999 [SYN] Seq=0 Win=65535 Len=0 MSS=1460
   85  12.723299     10.0.2.2 → 10.0.2.15    TCP 60 60566 → 19999 [ACK] Seq=1 Ack=1 Win=65535 Len=0
   86  12.723299     10.0.2.2 → 10.0.2.15    TCP 60 59269 → 19999 [ACK] Seq=1 Ack=1 Win=65535 Len=0
   87  12.723309    10.0.2.15 → 10.0.2.2     TCP 58 19999 → 57982 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=1460
..........

OUI можно увидеть в дампе с ключем ```-e```. Поскольку в виртуалке используется несуществующее оборудование, то OUI будет неизвестен:

```
vagrant@vagrant:~$ sudo tcpdump -i eth0 -c 50 -qe
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
13:44:43.763042 08:00:27:14:86:db (oui Unknown) > 52:54:00:12:35:02 (oui Unknown), IPv4, length 90: vagrant.ssh > _gateway.50988: tcp 36
13:44:43.763391 52:54:00:12:35:02 (oui Unknown) > 08:00:27:14:86:db (oui Unknown), IPv4, length 60: _gateway.50988 > vagrant.ssh: tcp 0
13:44:43.764525 08:00:27:14:86:db (oui Unknown) > 52:54:00:12:35:03 (oui Unknown), IPv4, length 92: vagrant.36645 > 10.0.2.3.domain: UDP, length 50
```


